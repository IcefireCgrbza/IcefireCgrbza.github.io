---
title: 1.内存分布
date: 2021-04-19 21:19:20
tags: 三、深入理解Java虚拟机
categories: 三、深入理解Java虚拟机
---

JVM内存区域包括 PC计数器、Java虚拟机栈、本地方法栈、堆、方法区、运行时常量池和直接内存

# PC计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码行号指示器，由线程私有

# 虚拟机栈

线程私有内存空间，它的生命周期和线程相同。线程执行期间，每个方法执行时都会创建一个栈帧(Stack Frame) ，用于存储 局部变量表、操作数栈 、动态链接 、方法出口等信息

+ 局部变量表：用于存储方法参数和局部变量；在编译期间分配内存空间，可以存放以下编译期的变量类型
    - 基本数据类型：boolean, byte, char, short, int, float, long, double等8种
    - 对象引用类型 ：reference，指向对象起始地址的引用指针
    - 返回地址类型 ：returnAddress，返回地址的类型
+ 操作数栈：虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用
+ 动态链接：每个栈帧都包含一个指向运行时常量池中所属的方法引用，持有这个引用是为了支持方法调用过程中的动态链接
    - 静态解析：一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等）
    - 动态解析：另一部分将在每一次的运行期间转化为直接引用
+ 方法返回地址
    - 正常返回：当执行遇到返回指令，会将返回值传递给上层的方法调用者
    - 异常返回：当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出

当一个方法返回时，可能依次进行以下3个操作： 1. 恢复上层方法的局部变量表和操作数栈。 2. 把返回值压入调用者栈帧的操作数栈。 3. 将PC计数器的值指向下一条方法指令位置

在Java虚拟机规范中，对这个区域规定了两种异常

1. 如果当前线程请求的栈深度大于虚拟机栈所允许的深度，将会抛出StackOverflowError异常（不允许动态拓展的情况下）
2. 如果扩展时无法申请到足够的内存空间，就会抛出 OutOfMemoryError 异常

# 本地方法栈

本地方法栈和Java虚拟机栈作用相似，主要区别是Java虚拟机栈执行的是Java方法，而本地方法栈执行Native方法

# 堆

堆由所有线程共享，用于存放对象实例，几乎所有的对象实例都在这里分配内存。

在Java中，为了更好的管理堆中对象的分配和回收，往往采用分代模型（详情参考垃圾回收章节）

+ 新生代 (Young Generation) 
    - Eden区：对象首先进入Eden区
    - Survivor区：有2个Survivor区，用于对象复制；前几次回收，存活对象由Eden区转移到Survivor区，再在两个Survivor区不断交换
+ 老年代 (Old Generation) ：在Survivor区的对象经历若干次收集仍然存活的，就会被转移到老年代Old中

# 方法区（Hotspot上称为永久代）

方法区和Java堆一样，为多个线程共享，它用于存储类信息、常量、静态常量和即时编译后的代码等数据

jdk8中，永久代改为元空间（Metaspace），使用直接内存进行管理；永久代大小受限于-XX:MaxPermSize，而元空间的容量可以动态扩缩

# 运行时常量池

运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法和接口等描述信息外， 还有一类信息是常量池，用于存储编译期间生成的各种字面量和符号引用

# 直接内存

直接内存不属于虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。例如Java NIO允许Java程序直接访问直接内存，通常直接内存的速度会优于Java堆内存。因此，对于读写频繁、性能要求高的场景，可以考虑使用直接内存。这往往也是最容易发生内存泄漏的地方

# 相关JVM参数

+ -Xms：堆的最小内存
+ -Xmx：堆的最大内存（经验上设置堆得最大内存为机器内存的2/3）
+ -Xss：栈内存大小
+ -XX:+HeapDumpOnOutOfMemoryError：虚拟机在出现内存溢出异常时Dump出内存堆运行时快照
+ -XX:PermSize：方法区最小内存
+ -XX:MaxPermSize：方法区最大内存
+ -XX:MaxDirectMemorySize：直接内存大小
+ -XX:MetaspaceSize：首次元空间GC的阈值
+ -XX:MaxMetaspaceSize：元空间的最大空间，默认是没有限制的
+ -XX:MinMetaspaceFreeRatio：在GC之后，元空间的空闲容量占比阈值，小于该占比会导致GC阈值提升
+ -XX:MaxMetaspaceFreeRatio：在GC之后，元空间的空闲容量占比阈值，大于该占比会导致GC阈值下降
+ -XX:MinMetaspaceExpansion：GC阈值最小增长
+ -XX:MaxMetaspaceExpansion：GC阈值最大增长

# 问题排查

### 堆内存溢出

Heap OOM（OutOfMemoryError: Java heap space）通常要考虑内存泄露和内存溢出两种可能性

+ 内存泄露：使用Java VisualVM工具进行分析，查看泄露对象是通过怎样的路径与GC Roots关联而导致垃圾回收器无法回收的。
+ 内存溢出：使用Java VisualVM工具分析，不存在泄露对象，也就是说堆内存中的对象必须得存活着。就要考虑如下措施：
    1. 从代码上检查是否存在某些对象生命周期过长、持续状态时间过长的情况，尝试减少程序运行期的内存
    2. 检查虚拟机的堆参数(-Xmx与-Xms)，对比机器的物理内存看是否还可以调大

### 虚拟机和本地方法栈溢出

关于虚拟机栈和本地方法栈，分析内存异常类型可能存在以下两种：

+ 如果现场请求的栈深度大于虚拟机所允许的最大深度，或是栈上局部变量过多，将抛出StackOverflowError异常。
+ 如果虚拟机在扩展栈时无法申请到足够的内存空间，可能会抛出java.lang.OutOfMemoryError: unable to create new native thread

### 运行时常量池/方法区溢出

java.lang.OutOfMemoryError: PermGen space